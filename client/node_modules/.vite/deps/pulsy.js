import {
  require_react
} from "./chunk-Z366RN5A.js";
import {
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/pulsy/dist/esm/index.js
var import_react = __toESM(require_react());
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var isDevelopment = true;
var logStyle = {
  info: "color: #1E90FF; font-weight: bold;",
  warn: "color: #FFA500; font-weight: bold;",
  error: "color: #FF4500; font-weight: bold;",
  measure: "color: #32CD32; font-weight: bold;",
  debug: "color: #9932CC; font-weight: bold;",
  group: "color: #4169E1; font-weight: bold;",
  none: "",
  groupEnd: ""
};
var devToolsConfig = {
  enableDevTools: isDevelopment,
  logLevel: "info",
  trackPerformance: true,
  enableConsoleGroups: true,
  enableStateTimeline: true
};
var configureDevTools = function(config) {
  devToolsConfig = __assign(__assign({}, devToolsConfig), config);
};
var stateTimeline = [];
var devTools = {
  log: function(message, style) {
    if (style === void 0) {
      style = "info";
    }
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (devToolsConfig.enableDevTools && (devToolsConfig.logLevel === style || devToolsConfig.logLevel === "info")) {
      if (devToolsConfig.enableConsoleGroups && style === "group") {
        console.group("%c".concat(message), logStyle[style]);
      } else if (style === "groupEnd") {
        console.groupEnd();
      } else {
        console.log.apply(console, __spreadArray(["%c".concat(message), logStyle[style]], args, false));
      }
    }
  },
  mark: function(markName) {
    if (devToolsConfig.enableDevTools && devToolsConfig.trackPerformance) {
      performance.mark(markName);
      devTools.log("Mark: ".concat(markName), "debug");
    }
  },
  measure: function(measureName, startMark, endMark) {
    if (devToolsConfig.enableDevTools && devToolsConfig.trackPerformance) {
      performance.measure(measureName, startMark, endMark);
      var measure = performance.getEntriesByName(measureName).pop();
      if (measure) {
        devTools.log("".concat(measureName, ": ").concat(measure.duration.toFixed(2), "ms"), "measure");
      }
    }
  },
  trackStateChange: function(storeName, value) {
    if (devToolsConfig.enableDevTools && devToolsConfig.enableStateTimeline) {
      stateTimeline.push({ timestamp: Date.now(), storeName, value });
      devTools.log("State changed: ".concat(storeName), "debug", value);
    }
  },
  getStateTimeline: function() {
    return stateTimeline;
  },
  clearStateTimeline: function() {
    stateTimeline.length = 0;
    devTools.log("State timeline cleared", "info");
  },
  logPerformance: function() {
    if (devToolsConfig.enableDevTools && devToolsConfig.trackPerformance) {
      var measures = performance.getEntriesByType("measure");
      devTools.log("Performance Summary:", "group");
      measures.forEach(function(measure) {
        devTools.log("".concat(measure.name, ": ").concat(measure.duration.toFixed(2), "ms"), "measure");
      });
      devTools.log("", "groupEnd");
    }
  },
  visualizeStateChanges: function() {
    if (devToolsConfig.enableDevTools && devToolsConfig.enableStateTimeline) {
      console.table(stateTimeline);
    }
  }
};
var defaultPersistenceOptions = {
  storage: localStorage,
  serialize: JSON.stringify,
  deserialize: JSON.parse,
  version: 1
};
var stores = /* @__PURE__ */ new Map();
var pulsyConfig = {
  enableDevTools: true,
  onStoreCreate: void 0,
  onStoreUpdate: void 0,
  persist: void 0,
  defaultMemoize: false
};
function configurePulsy(config) {
  var _a;
  pulsyConfig = __assign(__assign({}, pulsyConfig), config);
  configureDevTools({ enableDevTools: (_a = pulsyConfig.enableDevTools) !== null && _a !== void 0 ? _a : true });
  if (pulsyConfig.enableDevTools) {
    devTools.log("Pulsy configured", "info", pulsyConfig);
  }
}
function persistStore(name, value, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = __assign(__assign({}, defaultPersistenceOptions), options), storage = _a.storage, serialize = _a.serialize;
  try {
    var serializedValue = serialize({
      value,
      version: options.version || 1
    });
    storage.setItem("pulsy_".concat(name), serializedValue);
    devTools.log('Store "'.concat(name, '" persisted successfully.'), "info");
  } catch (error) {
    devTools.log('Error persisting store "'.concat(name, '": ').concat(error.message), "error");
  }
}
function retrievePersistedStore(name, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = __assign(__assign({}, defaultPersistenceOptions), options), storage = _a.storage, deserialize = _a.deserialize, version = _a.version, migrate = _a.migrate;
  try {
    var serializedValue = storage.getItem("pulsy_".concat(name));
    if (serializedValue) {
      var _b = deserialize(serializedValue), value = _b.value, storedVersion = _b.version;
      if (version && storedVersion !== version && migrate) {
        value = migrate(value, storedVersion);
        persistStore(name, value, __assign(__assign({}, options), { version }));
      }
      devTools.log('Store "'.concat(name, '" retrieved successfully.'), "info");
      return value;
    }
  } catch (error) {
    devTools.log('Error retrieving persisted store "'.concat(name, '": ').concat(error.message), "error");
  }
  return void 0;
}
function createStore(name, initialValue, options) {
  var _a, _b, _c;
  var persistOptions = typeof (options === null || options === void 0 ? void 0 : options.persist) === "object" ? options.persist : {};
  var shouldPersist = (options === null || options === void 0 ? void 0 : options.persist) || pulsyConfig.persist;
  var value = initialValue;
  if (shouldPersist) {
    var persistedValue = retrievePersistedStore(name, persistOptions);
    if (persistedValue !== void 0) {
      value = persistedValue;
    }
  }
  stores.set(name, {
    value,
    reloaders: /* @__PURE__ */ new Set(),
    middleware: (_a = options === null || options === void 0 ? void 0 : options.middleware) !== null && _a !== void 0 ? _a : [],
    memoize: (_c = (_b = options === null || options === void 0 ? void 0 : options.memoize) !== null && _b !== void 0 ? _b : pulsyConfig.defaultMemoize) !== null && _c !== void 0 ? _c : false,
    persist: shouldPersist
  });
  if (pulsyConfig.onStoreCreate) {
    pulsyConfig.onStoreCreate(name, value);
  }
  if (shouldPersist) {
    persistStore(name, value, persistOptions);
  }
  devTools.log("Store created: ".concat(name), "info", value);
}
function getStoreValue(name) {
  var store = stores.get(name);
  if (!store) {
    throw new Error('Store with name "'.concat(name, '" does not exist.'));
  }
  return store.value;
}
var createSetter = function(name) {
  return function(newValue) {
    return __awaiter(void 0, void 0, void 0, function() {
      var store, updatedValue_1, _i, _a, middleware, error_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            devTools.mark("usePulsy-setter-start-".concat(name));
            store = stores.get(name);
            if (!store) return [3, 7];
            _b.label = 1;
          case 1:
            _b.trys.push([1, 6, , 7]);
            updatedValue_1 = typeof newValue === "function" ? newValue(store.value) : newValue;
            _i = 0, _a = store.middleware;
            _b.label = 2;
          case 2:
            if (!(_i < _a.length)) return [3, 5];
            middleware = _a[_i];
            return [4, middleware(updatedValue_1, store.value, name)];
          case 3:
            updatedValue_1 = _b.sent();
            _b.label = 4;
          case 4:
            _i++;
            return [3, 2];
          case 5:
            store.value = updatedValue_1;
            store.reloaders.forEach(function(r) {
              return r(updatedValue_1);
            });
            if (pulsyConfig.onStoreUpdate) {
              pulsyConfig.onStoreUpdate(name, updatedValue_1);
            }
            if (store.persist) {
              persistStore(name, updatedValue_1, typeof store.persist === "object" ? store.persist : void 0);
            }
            devTools.mark("usePulsy-setter-end-".concat(name));
            devTools.measure("usePulsy-setter-".concat(name), "usePulsy-setter-start-".concat(name), "usePulsy-setter-end-".concat(name));
            return [3, 7];
          case 6:
            error_1 = _b.sent();
            devTools.log('Error updating store "'.concat(name, '": ').concat(error_1.message), "error");
            return [3, 7];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
};
function setStoreValue(name, value) {
  var setter = createSetter(name);
  setter(value);
}
function initializePulsy(storeConfigs, config) {
  if (config) {
    configurePulsy(config);
  }
  devTools.mark("initializePulsy-start");
  try {
    Object.entries(storeConfigs).forEach(function(_a) {
      var name = _a[0], initialValue = _a[1];
      if (typeof name !== "string") {
        throw new Error("Store name must be a string.");
      }
      createStore(name, initialValue);
    });
  } catch (error) {
    devTools.log("Error initializing stores: ".concat(error.message), "error");
  }
  devTools.mark("initializePulsy-end");
  devTools.log("Pulsy stores initialized", "info", Object.keys(storeConfigs));
}
function clearPersistedStores(storageType) {
  if (storageType === void 0) {
    storageType = localStorage;
  }
  Object.keys(storageType).forEach(function(key) {
    if (key.startsWith("pulsy_")) {
      storageType.removeItem(key);
    }
  });
  devTools.log("All persisted stores cleared.", "info");
}
function usePulsy(name) {
  var _this = this;
  var _a, _b;
  var storeRef = (0, import_react.useRef)();
  var _c = (0, import_react.useState)(function() {
    devTools.mark("usePulsy-init-start-".concat(name));
    var store = stores.get(name);
    if (!store) {
      throw new Error('Store with name "'.concat(name, '" does not exist.'));
    }
    storeRef.current = store;
    devTools.mark("usePulsy-init-end-".concat(name));
    return store.value;
  }), value = _c[0], setValue = _c[1];
  var setter = (0, import_react.useCallback)(function(newValue) {
    return __awaiter(_this, void 0, void 0, function() {
      var setter2;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, createSetter(name)];
          case 1:
            setter2 = _a2.sent();
            setter2(newValue);
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  (0, import_react.useEffect)(function() {
    devTools.mark("usePulsy-effect-start-".concat(name));
    var store = storeRef.current;
    store.reloaders.add(setValue);
    setValue(store.value);
    devTools.log("Effect run for store: ".concat(name), "info");
    return function() {
      store.reloaders.delete(setValue);
      devTools.mark("usePulsy-effect-end-".concat(name));
      devTools.measure("usePulsy-effect-".concat(name), "usePulsy-effect-start-".concat(name), "usePulsy-effect-end-".concat(name));
    };
  }, []);
  var memoizedValue = (0, import_react.useMemo)(function() {
    return value;
  }, [value, (_a = storeRef.current) === null || _a === void 0 ? void 0 : _a.memoize]);
  return [((_b = storeRef.current) === null || _b === void 0 ? void 0 : _b.memoize) ? memoizedValue : value, setter];
}
var createNamespacedStore = function(namespace) {
  return function(key) {
    return usePulsy("".concat(namespace, ":").concat(key));
  };
};
function addMiddleware(name, middleware) {
  var store = stores.get(name);
  if (!store) {
    throw new Error('Store with name "'.concat(name, '" does not exist.'));
  }
  store.middleware.push(middleware);
  devTools.log("Middleware added to store: ".concat(name), "info");
}
function useTimeTravel(name) {
  var _this = this;
  var _a = usePulsy(name), value = _a[0], setValue = _a[1];
  var historyRef = (0, import_react.useRef)([value]);
  var positionRef = (0, import_react.useRef)(0);
  var updateValue = (0, import_react.useCallback)(function(newValue) {
    return __awaiter(_this, void 0, void 0, function() {
      var updatedValue;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            updatedValue = typeof newValue === "function" ? newValue(value) : newValue;
            historyRef.current = historyRef.current.slice(0, positionRef.current + 1);
            historyRef.current.push(updatedValue);
            positionRef.current++;
            return [4, setValue(updatedValue)];
          case 1:
            _a2.sent();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [value, setValue]);
  var undo = (0, import_react.useCallback)(function() {
    if (positionRef.current > 0) {
      positionRef.current--;
      setValue(historyRef.current[positionRef.current]);
    }
  }, [setValue]);
  var redo = (0, import_react.useCallback)(function() {
    if (positionRef.current < historyRef.current.length - 1) {
      positionRef.current++;
      setValue(historyRef.current[positionRef.current]);
    }
  }, [setValue]);
  return [value, updateValue, undo, redo, historyRef.current];
}
function createComputedStore(name, computeFn, dependencies) {
  var computedValue = computeFn();
  createStore(name, computedValue);
  var updateComputedStore = function() {
    var newValue = computeFn();
    var store = stores.get(name);
    if (store) {
      store.value = newValue;
      store.reloaders.forEach(function(reloader) {
        return reloader(newValue);
      });
      if (pulsyConfig.onStoreUpdate) {
        pulsyConfig.onStoreUpdate(name, newValue);
      }
    }
  };
  dependencies.forEach(function(depName) {
    var depStore = stores.get(depName);
    if (depStore) {
      depStore.reloaders.add(updateComputedStore);
    }
  });
}
function composeStores(name, storeMap) {
  var _this = this;
  var composedValue = {};
  Object.entries(storeMap).forEach(function(_a) {
    var key = _a[0], storeName = _a[1];
    var store = stores.get(storeName);
    if (store) {
      composedValue[key] = store.value;
    }
  });
  createStore(name, composedValue);
  var updateComposedStore = function() {
    var newComposedValue = {};
    var hasChanges = false;
    Object.entries(storeMap).forEach(function(_a) {
      var key = _a[0], storeName = _a[1];
      var store = stores.get(storeName);
      if (store) {
        var value = store.value;
        if (value !== composedValue[key]) {
          newComposedValue[key] = value;
          hasChanges = true;
        } else {
          newComposedValue[key] = composedValue[key];
        }
      }
    });
    if (hasChanges) {
      var composedStore = stores.get(name);
      if (composedStore) {
        composedStore.value = newComposedValue;
        composedStore.reloaders.forEach(function(reloader) {
          return reloader(newComposedValue);
        });
        if (pulsyConfig.onStoreUpdate) {
          pulsyConfig.onStoreUpdate(name, newComposedValue);
        }
      }
    }
  };
  Object.values(storeMap).forEach(function(storeName) {
    var store = stores.get(storeName);
    if (store) {
      store.reloaders.add(updateComposedStore);
    }
  });
  var getComposedStore = function() {
    var store = stores.get(name);
    return store ? store.value : composedValue;
  };
  var setComposedStore = function(updates) {
    return __awaiter(_this, void 0, void 0, function() {
      var _loop_1, _i, _a, _b, key, value;
      return __generator(this, function(_c) {
        devTools.log("Updating composed store: ".concat(name), "info", updates);
        try {
          _loop_1 = function(key2, value2) {
            if (key2 in storeMap) {
              var store = stores.get(storeMap[key2]);
              if (store) {
                store.value = value2;
                store.reloaders.forEach(function(reloader) {
                  return reloader(value2);
                });
                if (pulsyConfig.onStoreUpdate) {
                  pulsyConfig.onStoreUpdate(storeMap[key2], value2);
                }
              }
            } else {
              devTools.log("No store found for key: ".concat(key2), "warn");
            }
          };
          for (_i = 0, _a = Object.entries(updates); _i < _a.length; _i++) {
            _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
          }
          devTools.log("Composed store updated successfully: ".concat(name), "info");
        } catch (error) {
          devTools.log("Error updating composed store: ".concat(name), "error", error);
        }
        return [
          2
          /*return*/
        ];
      });
    });
  };
  return [getComposedStore, setComposedStore];
}
function createActions(storeName, actionHandlers) {
  var actions = {};
  console.log(actionHandlers);
  var _loop_2 = function(type2) {
    if (Object.prototype.hasOwnProperty.call(actionHandlers, type2)) {
      actions[type2] = function(payload) {
        var _a;
        var store = stores.get(storeName);
        if (!store) {
          throw new Error('Store with name "'.concat(storeName, '" does not exist. Please ensure the store is initialized before dispatching actions.'));
        }
        var currentState = store.value;
        var action = { type: type2, payload };
        var newState = actionHandlers[type2](currentState, action);
        store.value = newState;
        store.reloaders.forEach(function(reloader) {
          return reloader(newState);
        });
        (_a = pulsyConfig.onStoreUpdate) === null || _a === void 0 ? void 0 : _a.call(pulsyConfig, storeName, newState);
        var shouldPersist = store.persist;
        if (shouldPersist) {
          try {
            localStorage.setItem(storeName, JSON.stringify(newState));
          } catch (error) {
            console.error('Failed to persist state for store "'.concat(storeName, '"'), error);
          }
        }
        return action;
      };
    }
  };
  for (var type in actionHandlers) {
    _loop_2(type);
  }
  return actions;
}
export {
  addMiddleware,
  clearPersistedStores,
  composeStores,
  configurePulsy,
  createActions,
  createComputedStore,
  createNamespacedStore,
  createSetter,
  createStore,
  usePulsy as default,
  devTools,
  getStoreValue,
  initializePulsy,
  setStoreValue,
  usePulsy,
  useTimeTravel
};
//# sourceMappingURL=pulsy.js.map
