type Middleware<T> = (nextValue: T, prevValue: T, storeName: string) => T | Promise<T>;
type PulsyConfig = {
    enableDevTools?: boolean;
    onStoreCreate?: (name: string, initialValue: any) => void;
    onStoreUpdate?: (name: string, newValue: any) => void;
    persist?: boolean;
    defaultMemoize?: boolean;
};
type PersistenceOptions = {
    storage?: Storage;
    serialize?: (value: any) => string;
    deserialize?: (value: string) => any;
    version?: number;
    migrate?: (persistedState: any, version: number) => any;
};
export declare function configurePulsy(config: PulsyConfig): void;
export declare function createStore<T>(name: string, initialValue: T, options?: {
    persist?: boolean | PersistenceOptions;
    middleware?: Middleware<T>[];
    memoize?: boolean;
}): void;
export declare function getStoreValue<T>(name: string): T | undefined;
export declare const createSetter: <T>(name: string) => (newValue: T | ((prevValue: T) => T)) => Promise<void>;
export declare function setStoreValue<T>(name: string, value: T): void;
export declare function initializePulsy(storeConfigs: Record<string, any>, config?: PulsyConfig): void;
/**
 * Clears all persisted stores from the specified storage type.
 *
 * This function iterates through all keys in the provided storage type
 * (default is `localStorage`) and removes any key that starts with "pulsy_".
 *
 * @param storageType - The storage type to clear the persisted stores from. Defaults to `localStorage`.
 *
 * @returns void
 */
export declare function clearPersistedStores(storageType?: Storage): void;
/**
 * Custom hook `usePulsy` for managing state with a store.
 *
 * @template T - The type of the state value.
 * @param {string} name - The name of the store.
 * @returns {[T, (newValue: T | ((prevValue: T) => T)) => Promise<void>]} - A tuple containing the current state value and a setter function to update the state.
 *
 * @throws {Error} If the store with the specified name does not exist.
 *
 * @example
 * const [value, setValue] = usePulsy<number>('counter');
 *
 * @remarks
 * The setter function updates the store value and notifies all reloaders. It also applies middleware and persists the store value if configured to do so.
 *
 * The hook initializes the state with the existing store value and sets up an effect to manage the store's reloaders.
 *
 * The state value is memoized if memoization is enabled for the store.
 */
export default function usePulsy<T>(name: string): [T, (newValue: T | ((prevValue: T) => T)) => Promise<void>];
/**
 * Creates a namespaced store function.
 *
 * This function generates a store function that prefixes the provided key with the given namespace.
 * It is useful for organizing and managing state in a modular way.
 *
 * @param namespace - The namespace to prefix the key with.
 * @returns A function that takes a key and returns the result of `usePulsy` with the namespaced key.
 *
 * @template T - The type of the state managed by the store.
 */
export declare const createNamespacedStore: (namespace: string) => <T>(key: string) => [T, (newValue: T | ((prevValue: T) => T)) => Promise<void>];
/**
 * Adds a middleware to the specified store.
 *
 * @template T - The type of the store's state.
 * @param {string} name - The name of the store to which the middleware will be added.
 * @param {Middleware<T>} middleware - The middleware function to add to the store.
 * @throws {Error} If the store with the specified name does not exist.
 * @returns {void}
 */
export declare function addMiddleware<T>(name: string, middleware: Middleware<T>): void;
/**
 * Custom hook to manage state with time travel capabilities.
 *
 * @template T - The type of the state value.
 * @param {string} name - The name of the state.
 * @returns {[
 *   T,
 *   (newValue: T | ((prevValue: T) => T)) => Promise<void>,
 *   () => void,
 *   () => void,
 *   T[]
 * ]} - Returns an array containing:
 *   - The current state value.
 *   - A function to update the state value.
 *   - A function to undo the last state change.
 *   - A function to redo the last undone state change.
 *   - An array representing the history of state values.
 */
export declare function useTimeTravel<T>(name: string): [
    T,
    (newValue: T | ((prevValue: T) => T)) => Promise<void>,
    () => void,
    () => void,
    T[]
];
export declare function createComputedStore<T>(name: string, computeFn: () => T, dependencies: string[]): void;
export declare function composeStores<T extends Record<string, any>>(name: string, storeMap: {
    [K in keyof T]: string;
}): [() => T, (updates: Partial<{
    [K in keyof T]: any;
}>) => Promise<void>];
type Action<T> = {
    type: string;
    payload?: T;
};
type ActionCreator<T> = (payload?: T) => Action<T>;
type ActionHandler<S, T> = (state: S, action: Action<T>) => S;
/**
 * Creates a set of action creators for a given store.
 *
 * @template S - The type of the state managed by the store.
 * @template T - The type of the payload for the actions.
 *
 * @param {string} storeName - The name of the store for which actions are being created.
 * @param {Record<string, ActionHandler<S, T>>} actionHandlers - An object where keys are action types and values are functions that handle the actions.
 *
 * @returns {Record<string, ActionCreator<T>>} - An object where keys are action types and values are action creator functions.
 *
 * @throws {Error} - Throws an error if the store with the given name does not exist.
 *
 * @example
 * ```typescript
 * const actionHandlers = {
 *   increment: (state, action) => ({ ...state, count: state.count + 1 }),
 *   decrement: (state, action) => ({ ...state, count: state.count - 1 }),
 * };
 *
 * const actions = createActions('counterStore', actionHandlers);
 *
 * actions.increment();
 * actions.decrement();
 * ```
 */
export declare function createActions<S, T>(storeName: string, actionHandlers: Record<string, ActionHandler<S, T>>): Record<string, ActionCreator<T>>;
export {};
