import { useRef, useState, useCallback, useEffect, useMemo } from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// DevTools file
var isDevelopment = process.env.NODE_ENV === "development";
var logStyle = {
    info: "color: #1E90FF; font-weight: bold;",
    warn: "color: #FFA500; font-weight: bold;",
    error: "color: #FF4500; font-weight: bold;",
    measure: "color: #32CD32; font-weight: bold;",
    debug: "color: #9932CC; font-weight: bold;",
    group: "color: #4169E1; font-weight: bold;",
    none: "",
    groupEnd: "",
};
var devToolsConfig = {
    enableDevTools: isDevelopment,
    logLevel: "info",
    trackPerformance: true,
    enableConsoleGroups: true,
    enableStateTimeline: true,
};
// Function to configure devTools
var configureDevTools = function (config) {
    devToolsConfig = __assign(__assign({}, devToolsConfig), config);
};
// Timeline to track state changes
var stateTimeline = [];
var devTools = {
    log: function (message, style) {
        if (style === void 0) { style = "info"; }
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (devToolsConfig.enableDevTools &&
            (devToolsConfig.logLevel === style || devToolsConfig.logLevel === "info")) {
            if (devToolsConfig.enableConsoleGroups && style === "group") {
                console.group("%c".concat(message), logStyle[style]);
            }
            else if (style === "groupEnd") {
                console.groupEnd();
            }
            else {
                console.log.apply(console, __spreadArray(["%c".concat(message), logStyle[style]], args, false));
            }
        }
    },
    mark: function (markName) {
        if (devToolsConfig.enableDevTools && devToolsConfig.trackPerformance) {
            performance.mark(markName);
            devTools.log("Mark: ".concat(markName), "debug");
        }
    },
    measure: function (measureName, startMark, endMark) {
        if (devToolsConfig.enableDevTools && devToolsConfig.trackPerformance) {
            performance.measure(measureName, startMark, endMark);
            var measure = performance.getEntriesByName(measureName).pop();
            if (measure) {
                devTools.log("".concat(measureName, ": ").concat(measure.duration.toFixed(2), "ms"), "measure");
            }
        }
    },
    trackStateChange: function (storeName, value) {
        if (devToolsConfig.enableDevTools && devToolsConfig.enableStateTimeline) {
            stateTimeline.push({ timestamp: Date.now(), storeName: storeName, value: value });
            devTools.log("State changed: ".concat(storeName), "debug", value);
        }
    },
    getStateTimeline: function () { return stateTimeline; },
    clearStateTimeline: function () {
        stateTimeline.length = 0;
        devTools.log("State timeline cleared", "info");
    },
    logPerformance: function () {
        if (devToolsConfig.enableDevTools && devToolsConfig.trackPerformance) {
            var measures = performance.getEntriesByType("measure");
            devTools.log("Performance Summary:", "group");
            measures.forEach(function (measure) {
                devTools.log("".concat(measure.name, ": ").concat(measure.duration.toFixed(2), "ms"), "measure");
            });
            devTools.log("", "groupEnd");
        }
    },
    visualizeStateChanges: function () {
        if (devToolsConfig.enableDevTools && devToolsConfig.enableStateTimeline) {
            console.table(stateTimeline);
        }
    },
};

// Default persistence options
var defaultPersistenceOptions = {
    storage: localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    version: 1,
};
// Map to hold the stores
var stores = new Map();
// Default configuration
var pulsyConfig = {
    enableDevTools: process.env.NODE_ENV === "development",
    onStoreCreate: undefined,
    onStoreUpdate: undefined,
    persist: undefined,
    defaultMemoize: false,
};
// Function to configure Pulsy
function configurePulsy(config) {
    var _a;
    pulsyConfig = __assign(__assign({}, pulsyConfig), config);
    configureDevTools({ enableDevTools: (_a = pulsyConfig.enableDevTools) !== null && _a !== void 0 ? _a : true });
    if (pulsyConfig.enableDevTools) {
        devTools.log("Pulsy configured", "info", pulsyConfig);
    }
}
// Function to persist a store
function persistStore(name, value, options) {
    if (options === void 0) { options = {}; }
    var _a = __assign(__assign({}, defaultPersistenceOptions), options), storage = _a.storage, serialize = _a.serialize;
    try {
        var serializedValue = serialize({
            value: value,
            version: options.version || 1,
        });
        storage.setItem("pulsy_".concat(name), serializedValue);
        devTools.log("Store \"".concat(name, "\" persisted successfully."), "info");
    }
    catch (error) {
        devTools.log("Error persisting store \"".concat(name, "\": ").concat(error.message), "error");
    }
}
// Function to retrieve a persisted store
function retrievePersistedStore(name, options) {
    if (options === void 0) { options = {}; }
    var _a = __assign(__assign({}, defaultPersistenceOptions), options), storage = _a.storage, deserialize = _a.deserialize, version = _a.version, migrate = _a.migrate;
    try {
        var serializedValue = storage.getItem("pulsy_".concat(name));
        if (serializedValue) {
            var _b = deserialize(serializedValue), value = _b.value, storedVersion = _b.version;
            // Perform migration if versions don't match
            if (version && storedVersion !== version && migrate) {
                value = migrate(value, storedVersion);
                // Re-persist the migrated value
                persistStore(name, value, __assign(__assign({}, options), { version: version }));
            }
            devTools.log("Store \"".concat(name, "\" retrieved successfully."), "info");
            return value;
        }
    }
    catch (error) {
        devTools.log("Error retrieving persisted store \"".concat(name, "\": ").concat(error.message), "error");
    }
    return undefined;
}
// Enhanced createStore function with improved persistence
function createStore(name, initialValue, options) {
    var _a, _b, _c;
    var persistOptions = typeof (options === null || options === void 0 ? void 0 : options.persist) === "object" ? options.persist : {};
    var shouldPersist = (options === null || options === void 0 ? void 0 : options.persist) || pulsyConfig.persist;
    var value = initialValue;
    if (shouldPersist) {
        var persistedValue = retrievePersistedStore(name, persistOptions);
        if (persistedValue !== undefined) {
            value = persistedValue;
        }
    }
    stores.set(name, {
        value: value,
        reloaders: new Set(),
        middleware: (_a = options === null || options === void 0 ? void 0 : options.middleware) !== null && _a !== void 0 ? _a : [],
        memoize: (_c = (_b = options === null || options === void 0 ? void 0 : options.memoize) !== null && _b !== void 0 ? _b : pulsyConfig.defaultMemoize) !== null && _c !== void 0 ? _c : false,
        persist: shouldPersist,
    });
    if (pulsyConfig.onStoreCreate) {
        pulsyConfig.onStoreCreate(name, value);
    }
    if (shouldPersist) {
        persistStore(name, value, persistOptions);
    }
    devTools.log("Store created: ".concat(name), "info", value);
}
// Function to get the value of a store
function getStoreValue(name) {
    var store = stores.get(name);
    if (!store) {
        throw new Error("Store with name \"".concat(name, "\" does not exist."));
    }
    return store.value;
}
// Enhanced setter function with improved persistence
var createSetter = function (name) {
    return function (newValue) { return __awaiter(void 0, void 0, void 0, function () {
        var store, updatedValue_1, _i, _a, middleware, error_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    devTools.mark("usePulsy-setter-start-".concat(name));
                    store = stores.get(name);
                    if (!store) return [3 /*break*/, 7];
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, , 7]);
                    updatedValue_1 = typeof newValue === "function"
                        ? newValue(store.value)
                        : newValue;
                    _i = 0, _a = store.middleware;
                    _b.label = 2;
                case 2:
                    if (!(_i < _a.length)) return [3 /*break*/, 5];
                    middleware = _a[_i];
                    return [4 /*yield*/, middleware(updatedValue_1, store.value, name)];
                case 3:
                    updatedValue_1 = _b.sent();
                    _b.label = 4;
                case 4:
                    _i++;
                    return [3 /*break*/, 2];
                case 5:
                    store.value = updatedValue_1;
                    store.reloaders.forEach(function (r) { return r(updatedValue_1); });
                    if (pulsyConfig.onStoreUpdate) {
                        pulsyConfig.onStoreUpdate(name, updatedValue_1);
                    }
                    if (store.persist) {
                        persistStore(name, updatedValue_1, typeof store.persist === "object" ? store.persist : undefined);
                    }
                    devTools.mark("usePulsy-setter-end-".concat(name));
                    devTools.measure("usePulsy-setter-".concat(name), "usePulsy-setter-start-".concat(name), "usePulsy-setter-end-".concat(name));
                    return [3 /*break*/, 7];
                case 6:
                    error_1 = _b.sent();
                    devTools.log("Error updating store \"".concat(name, "\": ").concat(error_1.message), "error");
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    }); };
};
function setStoreValue(name, value) {
    var setter = createSetter(name);
    setter(value);
}
// Function to initialize multiple stores at once with optional configuration
function initializePulsy(storeConfigs, config) {
    if (config) {
        configurePulsy(config);
    }
    devTools.mark("initializePulsy-start");
    try {
        Object.entries(storeConfigs).forEach(function (_a) {
            var name = _a[0], initialValue = _a[1];
            if (typeof name !== "string") {
                throw new Error("Store name must be a string.");
            }
            createStore(name, initialValue);
        });
    }
    catch (error) {
        devTools.log("Error initializing stores: ".concat(error.message), "error");
    }
    devTools.mark("initializePulsy-end");
    devTools.log("Pulsy stores initialized", "info", Object.keys(storeConfigs));
}
// Function to clear persisted stores
/**
 * Clears all persisted stores from the specified storage type.
 *
 * This function iterates through all keys in the provided storage type
 * (default is `localStorage`) and removes any key that starts with "pulsy_".
 *
 * @param storageType - The storage type to clear the persisted stores from. Defaults to `localStorage`.
 *
 * @returns void
 */
function clearPersistedStores(storageType) {
    if (storageType === void 0) { storageType = localStorage; }
    Object.keys(storageType).forEach(function (key) {
        if (key.startsWith("pulsy_")) {
            storageType.removeItem(key);
        }
    });
    devTools.log("All persisted stores cleared.", "info");
}
// Hook to use a Pulsy store
/**
 * Custom hook `usePulsy` for managing state with a store.
 *
 * @template T - The type of the state value.
 * @param {string} name - The name of the store.
 * @returns {[T, (newValue: T | ((prevValue: T) => T)) => Promise<void>]} - A tuple containing the current state value and a setter function to update the state.
 *
 * @throws {Error} If the store with the specified name does not exist.
 *
 * @example
 * const [value, setValue] = usePulsy<number>('counter');
 *
 * @remarks
 * The setter function updates the store value and notifies all reloaders. It also applies middleware and persists the store value if configured to do so.
 *
 * The hook initializes the state with the existing store value and sets up an effect to manage the store's reloaders.
 *
 * The state value is memoized if memoization is enabled for the store.
 */
function usePulsy(name) {
    var _this = this;
    var _a, _b;
    var storeRef = useRef();
    // Initialize state with the existing store value
    var _c = useState(function () {
        devTools.mark("usePulsy-init-start-".concat(name));
        var store = stores.get(name);
        if (!store) {
            throw new Error("Store with name \"".concat(name, "\" does not exist."));
        }
        storeRef.current = store;
        devTools.mark("usePulsy-init-end-".concat(name));
        return store.value;
    }), value = _c[0], setValue = _c[1];
    // Define setter function to update the store and notify all reloaders
    var setter = useCallback(function (newValue) { return __awaiter(_this, void 0, void 0, function () {
        var setter;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, createSetter(name)];
                case 1:
                    setter = _a.sent();
                    setter(newValue);
                    return [2 /*return*/];
            }
        });
    }); }, []);
    useEffect(function () {
        devTools.mark("usePulsy-effect-start-".concat(name));
        var store = storeRef.current;
        store.reloaders.add(setValue);
        setValue(store.value);
        devTools.log("Effect run for store: ".concat(name), "info");
        return function () {
            store.reloaders.delete(setValue);
            devTools.mark("usePulsy-effect-end-".concat(name));
            devTools.measure("usePulsy-effect-".concat(name), "usePulsy-effect-start-".concat(name), "usePulsy-effect-end-".concat(name));
        };
    }, []);
    // Memoize the value if memoization is enabled for this store
    var memoizedValue = useMemo(function () { return value; }, [value, (_a = storeRef.current) === null || _a === void 0 ? void 0 : _a.memoize]);
    return [((_b = storeRef.current) === null || _b === void 0 ? void 0 : _b.memoize) ? memoizedValue : value, setter];
}
// Utility function to create a namespaced store
/**
 * Creates a namespaced store function.
 *
 * This function generates a store function that prefixes the provided key with the given namespace.
 * It is useful for organizing and managing state in a modular way.
 *
 * @param namespace - The namespace to prefix the key with.
 * @returns A function that takes a key and returns the result of `usePulsy` with the namespaced key.
 *
 * @template T - The type of the state managed by the store.
 */
var createNamespacedStore = function (namespace) {
    return function (key) { return usePulsy("".concat(namespace, ":").concat(key)); };
};
// Function to add middleware to an existing store
/**
 * Adds a middleware to the specified store.
 *
 * @template T - The type of the store's state.
 * @param {string} name - The name of the store to which the middleware will be added.
 * @param {Middleware<T>} middleware - The middleware function to add to the store.
 * @throws {Error} If the store with the specified name does not exist.
 * @returns {void}
 */
function addMiddleware(name, middleware) {
    var store = stores.get(name);
    if (!store) {
        throw new Error("Store with name \"".concat(name, "\" does not exist."));
    }
    store.middleware.push(middleware);
    devTools.log("Middleware added to store: ".concat(name), "info");
}
/**
 * Custom hook to manage state with time travel capabilities.
 *
 * @template T - The type of the state value.
 * @param {string} name - The name of the state.
 * @returns {[
 *   T,
 *   (newValue: T | ((prevValue: T) => T)) => Promise<void>,
 *   () => void,
 *   () => void,
 *   T[]
 * ]} - Returns an array containing:
 *   - The current state value.
 *   - A function to update the state value.
 *   - A function to undo the last state change.
 *   - A function to redo the last undone state change.
 *   - An array representing the history of state values.
 */
function useTimeTravel(name) {
    var _this = this;
    var _a = usePulsy(name), value = _a[0], setValue = _a[1];
    var historyRef = useRef([value]);
    var positionRef = useRef(0);
    var updateValue = useCallback(function (newValue) { return __awaiter(_this, void 0, void 0, function () {
        var updatedValue;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    updatedValue = typeof newValue === "function"
                        ? newValue(value)
                        : newValue;
                    historyRef.current = historyRef.current.slice(0, positionRef.current + 1);
                    historyRef.current.push(updatedValue);
                    positionRef.current++;
                    return [4 /*yield*/, setValue(updatedValue)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); }, [value, setValue]);
    var undo = useCallback(function () {
        if (positionRef.current > 0) {
            positionRef.current--;
            setValue(historyRef.current[positionRef.current]);
        }
    }, [setValue]);
    var redo = useCallback(function () {
        if (positionRef.current < historyRef.current.length - 1) {
            positionRef.current++;
            setValue(historyRef.current[positionRef.current]);
        }
    }, [setValue]);
    return [value, updateValue, undo, redo, historyRef.current];
}
// Improved Computed Stores
function createComputedStore(name, computeFn, dependencies) {
    var computedValue = computeFn();
    createStore(name, computedValue);
    var updateComputedStore = function () {
        var newValue = computeFn();
        var store = stores.get(name);
        if (store) {
            store.value = newValue;
            store.reloaders.forEach(function (reloader) { return reloader(newValue); });
            if (pulsyConfig.onStoreUpdate) {
                pulsyConfig.onStoreUpdate(name, newValue);
            }
        }
    };
    dependencies.forEach(function (depName) {
        var depStore = stores.get(depName);
        if (depStore) {
            depStore.reloaders.add(updateComputedStore);
        }
    });
}
// Improved Compose Store
function composeStores(name, storeMap) {
    var _this = this;
    var composedValue = {};
    Object.entries(storeMap).forEach(function (_a) {
        var key = _a[0], storeName = _a[1];
        var store = stores.get(storeName);
        if (store) {
            composedValue[key] = store.value;
        }
    });
    createStore(name, composedValue);
    var updateComposedStore = function () {
        var newComposedValue = {};
        var hasChanges = false;
        Object.entries(storeMap).forEach(function (_a) {
            var key = _a[0], storeName = _a[1];
            var store = stores.get(storeName);
            if (store) {
                var value = store.value;
                if (value !== composedValue[key]) {
                    newComposedValue[key] = value;
                    hasChanges = true;
                }
                else {
                    newComposedValue[key] = composedValue[key];
                }
            }
        });
        if (hasChanges) {
            var composedStore = stores.get(name);
            if (composedStore) {
                composedStore.value = newComposedValue;
                composedStore.reloaders.forEach(function (reloader) {
                    return reloader(newComposedValue);
                });
                if (pulsyConfig.onStoreUpdate) {
                    pulsyConfig.onStoreUpdate(name, newComposedValue);
                }
            }
        }
    };
    Object.values(storeMap).forEach(function (storeName) {
        var store = stores.get(storeName);
        if (store) {
            store.reloaders.add(updateComposedStore);
        }
    });
    var getComposedStore = function () {
        var store = stores.get(name);
        return store ? store.value : composedValue;
    };
    var setComposedStore = function (updates) { return __awaiter(_this, void 0, void 0, function () {
        var _loop_1, _i, _a, _b, key, value;
        return __generator(this, function (_c) {
            devTools.log("Updating composed store: ".concat(name), "info", updates);
            try {
                _loop_1 = function (key, value) {
                    if (key in storeMap) {
                        var store = stores.get(storeMap[key]);
                        if (store) {
                            store.value = value;
                            store.reloaders.forEach(function (reloader) { return reloader(value); });
                            if (pulsyConfig.onStoreUpdate) {
                                pulsyConfig.onStoreUpdate(storeMap[key], value);
                            }
                        }
                    }
                    else {
                        devTools.log("No store found for key: ".concat(key), "warn");
                    }
                };
                for (_i = 0, _a = Object.entries(updates); _i < _a.length; _i++) {
                    _b = _a[_i], key = _b[0], value = _b[1];
                    _loop_1(key, value);
                }
                devTools.log("Composed store updated successfully: ".concat(name), "info");
            }
            catch (error) {
                devTools.log("Error updating composed store: ".concat(name), "error", error);
            }
            return [2 /*return*/];
        });
    }); };
    return [getComposedStore, setComposedStore];
}
/**
 * Creates a set of action creators for a given store.
 *
 * @template S - The type of the state managed by the store.
 * @template T - The type of the payload for the actions.
 *
 * @param {string} storeName - The name of the store for which actions are being created.
 * @param {Record<string, ActionHandler<S, T>>} actionHandlers - An object where keys are action types and values are functions that handle the actions.
 *
 * @returns {Record<string, ActionCreator<T>>} - An object where keys are action types and values are action creator functions.
 *
 * @throws {Error} - Throws an error if the store with the given name does not exist.
 *
 * @example
 * ```typescript
 * const actionHandlers = {
 *   increment: (state, action) => ({ ...state, count: state.count + 1 }),
 *   decrement: (state, action) => ({ ...state, count: state.count - 1 }),
 * };
 *
 * const actions = createActions('counterStore', actionHandlers);
 *
 * actions.increment();
 * actions.decrement();
 * ```
 */
function createActions(storeName, actionHandlers) {
    var actions = {};
    console.log(actionHandlers);
    var _loop_2 = function (type) {
        if (Object.prototype.hasOwnProperty.call(actionHandlers, type)) {
            actions[type] = function (payload) {
                var _a;
                var store = stores.get(storeName);
                if (!store) {
                    throw new Error("Store with name \"".concat(storeName, "\" does not exist. Please ensure the store is initialized before dispatching actions."));
                }
                var currentState = store.value;
                var action = { type: type, payload: payload };
                var newState = actionHandlers[type](currentState, action);
                // Update the store
                store.value = newState;
                store.reloaders.forEach(function (reloader) { return reloader(newState); });
                // Call optional onStoreUpdate callback if provided
                (_a = pulsyConfig.onStoreUpdate) === null || _a === void 0 ? void 0 : _a.call(pulsyConfig, storeName, newState);
                // Persist state if required
                var shouldPersist = store.persist;
                if (shouldPersist) {
                    try {
                        localStorage.setItem(storeName, JSON.stringify(newState));
                    }
                    catch (error) {
                        console.error("Failed to persist state for store \"".concat(storeName, "\""), error);
                    }
                }
                return action;
            };
        }
    };
    for (var type in actionHandlers) {
        _loop_2(type);
    }
    return actions;
}

export { addMiddleware, clearPersistedStores, composeStores, configurePulsy, createActions, createComputedStore, createNamespacedStore, createSetter, createStore, usePulsy as default, devTools, getStoreValue, initializePulsy, setStoreValue, usePulsy, useTimeTravel };
//# sourceMappingURL=index.js.map
